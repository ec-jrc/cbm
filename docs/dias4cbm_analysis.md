# Frontend

This page lists the frontend functionalities available to analysts, organized per tasks with the links to the technical documentation. These tools are designed to provide an interface to the CbM backend to explore Sentinel data. They help to develop new methods to detect agricultural practice. An introduction to the JRC CbM system based on a DIAS cloud infrastructure is provided in the [OVERVIEW OF THE SYSTEM ARCHITECTURE PAGES](https://jrc-cbm.readthedocs.io/en/latest/dias4cbm_architecture.html). The frontend is based on the data generated by the backend, documented in the [BACKEND PAGES](https://jrc-cbm.readthedocs.io/en/latest/dias4cbm_setup.html), and contributes to the tools and methods to process data and take decisions, documented in the [DATA ANALYTICS PAGES](https://jrc-cbm.readthedocs.io/en/latest/dias4cbm_use.html).

## Goals
The main functions of the JRC CbM frontend for data analysis are:  
* to integrate backend results into the Paying Agency (PA) workflow  
* to support analytics and development of methods  
* to facilitate the design and application of marker analysis for decision support  
* to provide access to relevant ancillary reference data  

While the CbM frontend can potentially access backend data directly, all the examples provided make use of the RESTful API set up as intermediate layer between users and data. The examples are based on Jupyter Notebooks and Python. Some mature frontend functionality of generic interest to many users may be integrated as backend logic, once they are created and tested.  

## Links to the technical documentation

**RESTful API functionalities**  
1. [RESTful API: ACCESS TIME SERIES](https://jrc-cbm.readthedocs.io/en/latest/api_time_series.html)  
2. [RESTful API: ACCESS IMAGE CHIPS](https://jrc-cbm.readthedocs.io/en/latest/api_sentinel_images.html)  
3. [RESTful API: SUPPORT TO DATA ANALYTICS](https://jrc-cbm.readthedocs.io/en/latest/api_analytics.html)  
4. [RESTful API: USE OF POST FOR ADVANCED SELECTIONS](https://jrc-cbm.readthedocs.io/en/latest/api_post_requests.html)  

**CbM Python package**  
5. [Python CbM: OVERVIEW OF THE PACKAGE](https://jrc-cbm.readthedocs.io/en/latest/cbm_overview.html)  
6. [Python CbM: INSTALLATION OF THE PACKAGE](https://jrc-cbm.readthedocs.io/en/latest/cbm_install.html)  
7. [Python CbM: CONFIGURATION OF THE PACKAGE](https://jrc-cbm.readthedocs.io/en/latest/cbm_config.html)  
8. [Python CbM: TRANSFERT OF DIAS CATAOG METADATA](https://jrc-cbm.readthedocs.io/en/latest/cbm_card.html)  
9. [Python CbM: EXTRACTION OF STATISTICS](https://jrc-cbm.readthedocs.io/en/latest/cbm_ext.html)  
10. [Python CbM: ASSESSMENT OF FOI HETEROGENEITY AND CARDINALITY](https://jrc-cbm.readthedocs.io/en/latest/cbm_foi.html)  
11. [Python CbM: GET TIME SERIES, CHIPS AND BACKGROUND IMAGES](https://jrc-cbm.readthedocs.io/en/latest/cbm_data.html)  

## RESTful API
JRC RESTful (see the [introduction to JRC CbM architecture](https://jrc-cbm.readthedocs.io/en/latest/dias4cbm_architecture.html) for more info) service requests have predefined logical query names that need to be configured with a set parameters. The response is a JSON formatted dictionary with the data requested by the user, extracted from the [JRC CbM database](https://jrc-cbm.readthedocs.io/en/latest/setup_database.html) or from the Sentinel images stored in the DIAS object storage. In the documentation pages you find the available queries with use examples.  

In the [Time series documentation page](https://jrc-cbm.readthedocs.io/en/latest/api_ts.html), you can see an example of the use of the *parcelByLocation* command to find a parcel ID for a given geographical location, *parcelTimeSeries* to get the signature time series for a parcel ID, and *parcelPeers* to retrieve parcels with the same crop type as the reference parcel within a certain distance. The documentation shows how to integrate these RESTful queries in a Python script to generate products such as graphs.  

In the [Image chips documentation page](https://jrc-cbm.readthedocs.io/en/latest/api_imgs.html), we describe the use of the *chipByLocation* command to generate a series of extracted Sentinel-2 LEVEL2A segments of 128x128 pixels as a composite of 3 bands, *backgroundByLocation* to extract a high resolution overview of the parcel situation based on Google and Bing (or Virtual Earth) background image sets (does not depend on DIAS S3 store), *rawChipByLocation* to generate a series of extracted Sentinel-2 LEVEL2A segments of 128x128 (10m resolution bands) or 64x64 (20 m) pixels as list of full resolution GeoTIFFs. A more structured example shows how to integrate these RESTful services with some more advanced processing concepts that help build up to more complex logic in the next steps.  
https://jrc-cbm.readthedocs.io/en/latest/dias4cbm_use.html
In the [Data analytics documentation page](https://jrc-cbm.readthedocs.io/en/latest/api_analytics.html), we work out a case study for CbM using the RESTful services. For a limited area of interest, we illustrate how to select all parcel IDs, then for each of them how to check the extracted signature statistics. Given specific criteria, we show how to sort on expected heterogeneity of the parcels to check if it is meaningful with respect to the crop stage. For the top 10 heterogeneous parcels, we explain how to extract chips for further testing.  
This documentation page is still **under development**.

In the [POST documentation page](https://jrc-cbm.readthedocs.io/en/latest/api_post.html), we show how to use [POST methods](https://restfulapi.net/http-methods) with RESTful services, instead of GET methods, to perform tailored made selections. Using POST has the additional advantage that it is much easier to provide request parameters as more complex structures, e.g. including lists. In the documentation we present to script that are based on POST methods.  
In the example based on *rawChipsBatch*, you can see how to extract a set of image chips. In this case the parameters are lists of detailed references to individual chip selections that you want to collect from the server and that are then extracted on parallel Virtual Machines on the server. The script screens for cloud-free bands of interest. It generates an NDVI map and scales the result to a byte image with a colour palette of choice.  
The example based on *rawS1ChipsBatch* is analogue to the rawChipBatch query. This script retrieves Sentinel-1 chips setting the date range selection exploiting the convenience of POSTing JSON structures to pass on the request parameters.  

## Python CbM package  
We created the **CbM Python library** to provide an easy and organized way to run a variety of different tasks for CbM using [Python programming language](https://www.python.org/).  
In the [Overview page](https://jrc-cbm.readthedocs.io/en/latest/cbm_overview.html) we introduce the functions that part of the CbM package and we describe its sub-package *ipycbm*, focussed on interactive graphical configuration panels and data visualization tools for [Jupyter Notebooks](https://jupyter.org/).  

In the [Installation page](https://jrc-cbm.readthedocs.io/en/latest/cbm_install.html) and in the [Setup page](https://jrc-cbm.readthedocs.io/en/latest/cbm_config.html), we document how to install the package and its dependencies, and how to configure it, while in the [DIAS catalogue page](https://jrc-cbm.readthedocs.io/en/latest/cbm_card.html) we describe how we implemented a metadata transfer step, which makes metadata available in a single, consistent, database table *dias_catalogue* across the various DIAS instances in order to minimize portability issues. This page is still **under development**.  

In the [Extraction of statistics page](https://jrc-cbm.readthedocs.io/en/latest/cbm_ext.html) we explain how to configure the connection parameters for the database and the S3 storage and then how to use the *cbm.extract.s2* command to extract statistics in a given time range. We show how to use *ipycbm.extract()* to activate a graphical interface to run the extraction.  

In the [Feature Of Interest (FOI) assessment page](https://jrc-cbm.readthedocs.io/en/latest/cbm_foi.html) we document how to verify that the declared parcels correspond to homogeneous areas on the ground. In JRC CbM a FOI is the area that represents an homogeneous surface, which means that in FOI polygons there should be only one type of land use on the same type of land cover, and consequently that it is observable by the Sentinel as a meaningful individual entity (i.e. the signal of the pixels that are part of the FOI is similar). To verify that this condition is met, you can use the result of an image classification algorithm and verify that each unit does not contains clusters of heterogeneous pixels. We illustrate two methods provided by the CbM Python package: one based on area calculation (version 1) and one based on cluster size calculation (version 2). We show how to use this tool with a graphical user interface through the *ipycbm.foi()* command.  

In the [Get module page](https://jrc-cbm.readthedocs.io/en/latest/cbm_get.html), we present the code to use GET to retrieve a set of information. With *cbm.get.time_series.by_pid* you can get the signal time series of a band for a given parcel. With *cbm.get.chip_images.by_pid* you can download the chip image that corresponds to a given parcel. With *cbm.get.background.by_location* and *cbm.get.background.by_pid* you can download a background image (orthophoto) by selected location or parcel id. You can also learn how to use *ipycbm.get()* function to active an interactive Jupyter Notebook widget to get data from different sources, with variety of different methods (coordinates, parcels ids, map marker, polygon).    

## Expertise required
Analysts in Member States/Paying Agencies that work on the CbM using the frontend tools must have the following expertise:

* strong skills in Python coding  
* working knowledge of geospatial data processing  
* working knowledge of remote sensing  
* working knowledge of Sentinel data specifications, processing toolkits, and use case requirements in agriculture  

Developers that creates the frontend services must have the following expertise:

* strong skills in server interfaces for data access and analytics (Jupyter Hub, RESTful)
